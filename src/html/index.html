<html>

<head>
  <title>TAKASHI & KIYOKO by EMINA</title>
  <meta name="viewport" content="width=device-width">
  <link rel="stylesheet" href="codeKeyframes.css">

  <!-- Open Graph tags for social media -->
  <meta property="og:title" content="TAKASHI & KIYOKO Interactive Music Video">
  <meta property="og:description" content="Music by EMINA, Visual by d0n.xyz, Presented by Gridwalk">
  <meta property="og:image" content="https://emina.gridwalk.net/takashi-kiyoko/poster.png">
  <meta property="og:url" content="https://emina.gridwalk.net/takashi-kiyoko">
  <meta name="twitter:card" content="summary_large_image">
  <meta property="og:site_name" content="TAKASHI & KIYOKO Interactive Music Video">

  <style>

  	html{
  		visibility: visible!important;
  	}

    body{
    	background-color: #000;
    	overflow: hidden;
    	color:#fff;
    	font-family: monaco, monospace;
  		-webkit-font-smoothing:antialiased;
    	margin: 0;
    	padding: 0;
    	font-size: 12px;
    }

    a{
    	color:#00ccc2;
    }

    #content {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
    }
    canvas:not(.control){
    	position: absolute;
    	z-index: 1;
    }
    label {
    	position: relative;
    	color : #7a7a7a;
      font-size : 11px;
      display: flex;
      
    }

    .face-controls{
    	position: fixed;
    	top: 0;
    	left: 0;
    	height: 100%;
    	display: flex;
    	flex-direction: column;
    	z-index: 2;
    	display: none;
    }

		@media (max-height: 400px){
			.ckf-loading{
				flex-direction: row;
				justify-content: space-evenly;
			}
			.ckf-loading>*{
				max-width:50%!important;
			}
		}
    
  </style>
</head>

<body>


	<!-- CLM -->

	<div id="content">
    <canvas id="compare"></canvas>
    <br>
	</div>
  
  <!-- <div class="face-controls">
    <label>0 <input type="range" name="param1" min="0" max="10" step='0.1' oninput="rangeInput(this.value, 0)"></label>
    <label>4 <input type="range" name="param2" min="-60" max="60" oninput="rangeInput(this.value, 4)"></label>
    <label>5 <input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 5)"></label>
    <label>6 <input type="range" name="param1" min="-60" max="60" oninput="rangeInput(this.value, 6)"></label>
    <label>7 <input type="range" name="param2" min="-60" max="60" oninput="rangeInput(this.value, 7)"></label>
    <label>8 <input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 8)"></label>
    <label>9 <input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 9)"></label>
    <label>10<input type="range" name="param1" min="-60" max="60" oninput="rangeInput(this.value, 10)"></label>
    <label>11<input type="range" name="param2" min="-60" max="60" oninput="rangeInput(this.value, 11)"></label>
    <label>12<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 12)"></label>
    <label>13<input type="range" name="param1" min="-60" max="60" oninput="rangeInput(this.value, 13)"></label>
    <label>14<input type="range" name="param2" min="-60" max="60" oninput="rangeInput(this.value, 14)"></label>
    <label>15<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 15)"></label>
    <label>16<input type="range" name="param1" min="-60" max="60" oninput="rangeInput(this.value, 16)"></label>
    <label>17<input type="range" name="param2" min="-60" max="60" oninput="rangeInput(this.value, 17)"></label>
    <label>18<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 18)"></label>
    <label>19<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 19)"></label>    	
    <label>20<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 20)"></label>    	
    <label>21<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 21)"></label>    	
    <label>22<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 22)"></label>    	
    <label>23<input type="range" name="param3" min="-60" max="60" oninput="rangeInput(this.value, 23)"></label>    	
  </div> -->

	<script src='./vendor-js/clm-model.js'></script>
	<!-- helpers -->
	<script>
	
		// helper functions
		function rRange(min, max) {
		  return Math.random() * (max - min) + min;
		}

		function r(max) {
			return Math.random() * max
		}

		Array.prototype.random = function () {
		  return this[Math.floor((Math.random()*this.length))];
		}

	</script>
	<script>
		
		
		// Global variables

		// face stuff
		var x, y, i, path
		var xOffset = 0
		var yOffset = 0
		var faceScale = window.innerWidth * 0.003
		var singing = false
		var singingCounter = 0
		var paramsRange = [faceScale, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
		var faceColor = '#000'
		var clearFaceCanvas = true
		var canvasInput = document.getElementById('compare');
		var positionFlop = 0
		var morphAmount = 5
		var faceOpacityInterval = null

		var context = canvasInput.getContext('2d')

		// three js stuff

		var pyramidGroupRotation = 0

		fixFaceScale()

		// range input puppetry listener

		// function rangeInput(val, num) {
		//   paramsRange[num] = val;
		//   fixFaceScale()
		//   if(clearFaceCanvas) context.clearRect(0,0,window.innerWidth,window.innerHeight)
		//   drawFace(document.getElementById('compare'), paramsRange);     
		// }


		function drawPath(canvasContext, path, dp) {
			canvasContext.beginPath();
			var i, x, y;
			for (var p = 0;p < path.length;p++) {
				i = path[p]*2;
				x = pModel.shapeModel.meanShape[i/2][0];
				y = pModel.shapeModel.meanShape[i/2][1];
				for (var j = 0;j < pModel.shapeModel.numEvalues;j++) {
					x += pModel.shapeModel.eigenVectors[i][j]*dp[j+4];
					y += pModel.shapeModel.eigenVectors[i+1][j]*dp[j+4];
				}
				a = dp[0]*x - dp[1]*y + dp[2];
				b = dp[0]*y + dp[1]*x + dp[3];
				x += a;
				y += b;

				x = x+xOffset
				y = y+yOffset

				if (i == 0) {
					canvasContext.moveTo(x,y);
				} else {
					canvasContext.lineTo(x,y);
				}
			}
			canvasContext.moveTo(0,0);
			canvasContext.closePath();
			canvasContext.stroke();
		}

		function drawPoint(canvasContext, point, dp) {
		  var i, x, y;
		  i = point*2;
			x = pModel.shapeModel.meanShape[i/2][0];
		  y = pModel.shapeModel.meanShape[i/2][1];
			for (var j = 0;j < pModel.shapeModel.numEvalues;j++) {
				x += pModel.shapeModel.eigenVectors[i][j]*dp[j+4];
				y += pModel.shapeModel.eigenVectors[i+1][j]*dp[j+4];
			}
			a = dp[0]*x - dp[1]*y + dp[2];
			b = dp[0]*y + dp[1]*x + dp[3];
			x += a;
			y += b;

			x = x+xOffset
			y = y+yOffset


			canvasContext.beginPath();
		  canvasContext.arc(x, y, 2, 0, Math.PI*2, true);
			canvasContext.closePath();
			canvasContext.fill();
		}


		var drawFace = function(canvas, pv) {

		  // if no previous points, just draw in the middle of canvas
		  var params;
		  if (pv === undefined) {
		    params = currentParameters.slice(0);
		  } else {
		    params = pv.slice(0);
		  }

		  context = canvas.getContext('2d');
		  context.fillStyle = faceColor;
		  context.strokeStyle = faceColor;
		  context.save();

		  var paths = pModel.path.normal;
		  for (var i = 0;i < paths.length;i++) {
		    if (typeof(paths[i]) == 'number') {
		      drawPoint(context, paths[i], params);
		    } else {
		      drawPath(context, paths[i], params);
		    }
		  }

		  context.restore()
		}

		function fixFaceScale() {
			var faceScale = paramsRange[0]
			
			var faceX = (window.innerWidth / 2) - ((faceScale*115)/2)  
			paramsRange[2] = faceX

			var faceY = (window.innerHeight / 2) - ((faceScale*115)/2)  
			paramsRange[3] = faceY

		}

		function vocalize(increment) {
			paramsRange[6] = -10
			if( voxLoop ) clearInterval(voxLoop)
			if(!increment) increment = 2
			var voxLoop = setInterval(function(){
				paramsRange[6] = paramsRange[6] + increment
				if( paramsRange[6] >= 10 ) clearInterval(voxLoop)
			},25)
		}

		function randomizeFacePosition(){
			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
			var facePan
			if( positionFlop ){
				xOffset = rRange( window.innerWidth*-.4, ((window.innerWidth*0.2)*-1) )
				facePan = rRange(30,60)
				positionFlop = 0
			}else{
				xOffset = rRange( (window.innerWidth*0.2), window.innerWidth*.4 )			
				facePan = rRange(-60,-30)
				positionFlop = 1
			}

			paramsRange[4] = facePan

			yOffset = rRange( (window.innerHeight*-0.4), (window.innerHeight*0.4) )
		}

		function centerFace(increment){

			// face size
			paramsRange[0] = window.innerWidth * 0.004
			if( window.innerWidth < 900 ) paramsRange[0] = window.innerWidth * 0.006
			fixFaceScale()

			// zero out everything
			var zeroed = true
			for (var i = 4; i < paramsRange.length; i++) {
				if( paramsRange[i] > 0 ) paramsRange[i] -= increment
				if( paramsRange[i] < 0 ) paramsRange[i] += increment
				if( paramsRange[i] < -10 || paramsRange[i] > 10 ) zeroed = false
			}

			if( xOffset > -30 ) xOffset -= increment
			if( xOffset < -30 ) xOffset += increment
			if( yOffset > 0 ) yOffset -= increment
			if( yOffset < 0 ) yOffset += increment

			if( xOffset < -40 || xOffset > -20 || yOffset < -10 || yOffset > 10 ) zeroed = false

			// if any param is not zeroed out, run this again
			if( !zeroed ){
				setTimeout(function(){
					centerFace(increment)
				},10)
			}

		}

		function resetFace(){
			for (var i = 4; i < paramsRange.length; i++) {
				paramsRange[i] = 0
			}
		}

		function fadeFaceOut() {
			clearInterval(faceOpacityInterval)
			var o = 1
			faceOpacityInterval = setInterval(function(){
				window.compare.style.opacity = o
				o -= 0.025
				if( o <= 0 ) clearInterval(faceOpacityInterval)
			},25)
		}

		function randomizeFaceScale() {
			paramsRange[0] = rRange( window.innerWidth * 0.002, window.innerWidth * 0.004)
			fixFaceScale()
		}

		function blinkFace() {
			vocalize()
			randomizeFacePosition()
			randomizeFaceScale()
		}

		function doMorphs2(){
			var paramKey = Math.floor(rRange(6,23))
			paramsRange[paramKey] += r( morphAmount ) - (morphAmount/2)
		}
					
	</script>

	
  <script src='./vendor-js/three.min.js'></script>

	<!-- Set up the Three JS scene -->
	<script>

		var _body = document.querySelector('body')
		var winW = window.innerWidth
		var winH = window.innerHeight

		var scene     = new THREE.Scene()
		var maxRender = 50
		var camera    = new THREE.PerspectiveCamera(50, winW / winH, 0.01, maxRender)

		var renderer = new THREE.WebGLRenderer({
		  antialias: false,
		  alpha:true,
		  preserveDrawingBuffer:true
		})

		renderer.autoClearColor = true

		renderer.setSize(winW, winH)
		_body.appendChild(renderer.domElement)
		
		// create pyramids
		var radius = 4
		var height = 5

		var geometry = new THREE.OctahedronGeometry(radius, 0)
		var material = new THREE.MeshNormalMaterial()
		var pyramid  = new THREE.Mesh(geometry, material)
		var pyramid2 = new THREE.Mesh(geometry, material)
		
		var pyramidGroup = new THREE.Group()

		pyramidGroup.add(pyramid)
		pyramidGroup.add(pyramid2)
		scene.add(pyramidGroup)

		pyramid.rotation.z = -0.5

		// Make a cube
		var boxGeometry = new THREE.CubeGeometry(7.5, 7.5, 7.5)
		var boxMaterial = new THREE.MeshBasicMaterial({
		  color: '#fff',
		  wireframe: true,
		})

		var boxGroup = new THREE.Group()
		var boxMesh = new THREE.Mesh(boxGeometry, boxMaterial)
		boxGroup.add(boxMesh)
		scene.add(boxGroup)
		camera.position.z = 15

		function spinPyramids(){

			context.clearRect(0,0,window.innerWidth,window.innerHeight)

			var axises = ['x','y','z']

			var axis1 = axises.random()
			var axis2 = axises.random()

			window.spinPyAmount = 0.10
			window.offsetCounter = 0
			window.spinPyrInt = setInterval(function(){
				
				offsetCounter++
				spinPyAmount -= 0.0005

				var frequency = 0.0031
				var offset = Math.sin(offsetCounter * 2 * Math.PI * frequency) * 2;

				pyramid.position.x   = offset 
		   	pyramid2.position.x  = offset*-1

				pyramid.rotation[ axis1 ]  -= spinPyAmount
				pyramid2.rotation[ axis2 ] += spinPyAmount

				if( spinPyAmount <= 0 ) clearInterval(spinPyrInt)
			},10)
		}

		var inFormation2 = false
		function pyramidFormation2(){

			inFormation2 = true

			camera.far = 30
	    if( window.innerWidth > 500  ) camera.far = 21
	    if( window.innerWidth > 900  ) camera.far = 18
	    camera.updateProjectionMatrix();

			window.formation2 = setInterval(function(){
				
				var finished = true

				if( ckf.state.pyramidXOffset < 30 ){
					ckf.state.pyramidXOffset = parseFloat(ckf.state.pyramidXOffset) + 0.1
					finished = false
				}

				if( ckf.state.pyramidGroupScale > 0.2 ){
					ckf.state.pyramidGroupScale -= 0.0027
					finished = false
				}
				

				if( finished ) clearInterval(formation2)

			},10)			
		}

		// Resize stuff
		window.addEventListener( 'resize', onWindowResize, false );
		window.addEventListener("orientationchange", onWindowResize );

		function onWindowResize(){
			// resize face canvas
			canvasInput.setAttribute('width',window.innerWidth)
			canvasInput.setAttribute('height',window.innerHeight)

			// resize Three js canvas
	    camera.aspect = window.innerWidth / window.innerHeight
	    camera.updateProjectionMatrix()
	    renderer.setSize( window.innerWidth, window.innerHeight )

	    camera.position.z = 25
	    if( window.innerWidth > 500  ) camera.position.z = 20
	    if( window.innerWidth > 900  ) camera.position.z = 15

	    if( inFormation2 ) centerFace(1)
		}

		onWindowResize()



		var touchOnlyStart = function(){
			faceColor = '#00ccc2'
			window.previousParamsRange = paramsRange.slice(0)
			window.previousMorph = morphAmount
			morphAmount = morphAmount + 20			
			boxMesh.material.color.setHex( 0x00ccc2 )
		}

		var touchOnlyEnd = function(){
			faceColor = '#fff'
			newFacePan =  paramsRange[4]
			morphAmount = previousMorph
			paramsRange = previousParamsRange
			paramsRange[4] = newFacePan			
			boxMesh.material.color.setHex( 0xffffff )
		}

		var mouseOnlyStart = function(){
			faceColor = '#00ccc2'
			window.previousParamsRange = paramsRange.slice(0)
			window.previousMorph = morphAmount
			morphAmount = morphAmount + 20			
			boxMesh.material.color.setHex( 0x00ccc2 )
		}

		var mouseOnlyEnd = function(){
			faceColor = '#fff'
			newFacePan =  paramsRange[4]
			morphAmount = previousMorph
			paramsRange = previousParamsRange
			paramsRange[4] = newFacePan			
			boxMesh.material.color.setHex( 0xffffff )
		}

		_body.addEventListener("touchstart",touchOnlyStart,false)
		_body.addEventListener("touchend",touchOnlyEnd,false)
		_body.addEventListener("mousedown",mouseOnlyStart,false)
		_body.addEventListener("mouseup",mouseOnlyEnd,false)

	</script>

	<!-- Required inclusion of codekeyframes -->
  <script src='./codeKeyframes.js'></script>

  <!-- exported keyframes saved in a separate file -->
  <script src='./exported-keyframes.js'></script>

	<!-- CKF Initialization -->
  <script>
    var ckf = new CodeKeyframes({
      
      audioPath:     './audio/takashi-and-kiyoko.mp3',
      editorOpen:    false,
      hideWave:      true,
      waveColor:     '#3AEAD2',
      progressColor: '#0c9fa7',
      bgColor:       '#222',
      label:         'TAKASHI & KIYOKO by EMINA | Visual: d0n.xyz',
      autoplay:      false,
      loadingText: `<a href='https://eminagold.bandcamp.com' target='_blank'><img src="./img/emina-cover.jpg"></a>
      	<h1>TAKASHI &amp; KIYOKO</h1>
				<div>MUSIC: <a href='https://eminagold.bandcamp.com' target='_blank'>EMINA</a></div>
				<div>VISUAL: <a href="https://d0n.xyz" target='_blank'>d0n.xyz</a></div>
				<div>Presented by <a href="https://gridwalk.net">Gridwalk</a></div>`,      
      state: {
      	pyramidGroupScale: 1,
      	pyramidXOffset:    0,
      	cubeScale:         1,
      	cubeSineRange:     0.1,
      },

      keyframes: exportedKeyframes,
      
      onCanPlay: function(){

      	// auto Mute
      	// document.querySelector('.ckf-audio-toggle').click()
     
      },

      onPlay: function(){
     
      },

      onPause: function(){
     
      },

      onFrame: function(time){

      	// var sin60 = Math.sin(time/2) * 60
      	// console.log(sin60)
      	// if( !isNaN(sin60) )	paramsRange[5] = sin60


      	// draw face
      	
      	// black out canvas
      	if( clearFaceCanvas ){
      		context.fillStyle = 'rgba(0, 0, 0, .03)';
      		context.fillRect(0,0,window.innerWidth,window.innerHeight)
      	}

      	if( singing ){
      		singingCounter++
      		singingCounter = singingCounter % 5
      		if( singingCounter == 0 ) paramsRange[6] = rRange(-30,10)
      	}

      	if( time && time > 0.25 ){
	      	doMorphs2()
      		drawFace(document.getElementById('compare'), paramsRange)
      	}

      	// pyramid.rotation.z  += 0.0005
		    pyramid.rotation.y  += 0.005
		    
		    // pyramid2.rotation.z -= 0.0005
		    pyramid2.rotation.y -= 0.005
		   	
		   	boxMesh.rotation.y  -= 0.008

		   	pyramidGroup.rotation.y += pyramidGroupRotation
		   	pyramidGroup.rotation.x = Math.sin(pyramidGroup.rotation.y * 2 * Math.PI * 0.1)


		   	// pyramidGroup.rotation.z += 

		   	// hook in the variables we declared in ckf.state
		   	pyramidGroup.scale.x = ckf.state.pyramidGroupScale
		   	pyramidGroup.scale.y = ckf.state.pyramidGroupScale
		   	pyramidGroup.scale.z = ckf.state.pyramidGroupScale
		   	pyramid.position.x   = ckf.state.pyramidXOffset
		   	pyramid2.position.x  = ckf.state.pyramidXOffset*-1

		   	boxGroup.scale.x      = ckf.state.cubeScale
		   	boxGroup.scale.y      = ckf.state.cubeScale
		   	boxGroup.scale.z      = ckf.state.cubeScale

		   	// lock cube to camera
		   	boxGroup.quaternion.copy(camera.quaternion)

		  	// do Three JS rendering
		    renderer.render(scene, camera)
      },

      onFinish: function(){
      	document.querySelector('.ckf-start').remove()
      	document.querySelector('.ckf-loading').classList.remove('hidden')
      }
    })
  </script>

</body>
</html>